# Estrutura de Dados em Python

Este repositório contém implementações e explicação detalhada de estruturas de dados e algoritmos em Python. A compreensão desses conceitos é fundamental para qualquer desenvolvedor, pois eles formam a base para a resolução eficiente de problemas computacionais.

## Importância da Estrutura de Dados na Computação

As estruturas de dados são ferramentas fundamentais na ciência da computação, pois fornecem maneiras eficientes de armazenar, organizar e manipular dados. A escolha adequada de estruturas de dados pode ter um impacto significativo no desempenho e na eficiência de um programa. Dominar esse assunto é crucial para desenvolvedores que buscam criar soluções eficientes e escaláveis.

## Vantagens de Dominar Estrutura de Dados

1. **Eficiência:** Algoritmos eficientes baseados em estruturas de dados bem escolhidas resultam em programas mais rápidos e responsivos.
2. **Escalabilidade:** Compreender estruturas de dados permite criar sistemas que podem lidar com grandes volumes de dados sem sacrificar o desempenho.
3. **Resolução de Problemas:** Muitos problemas computacionais podem ser resolvidos de maneira mais elegante e rápida com o conhecimento apropriado de estruturas de dados.
4. **Entendimento Profundo:** Dominar estruturas de dados proporciona uma compreensão mais profunda dos fundamentos da ciência da computação.

## Algoritmos e Estruturas de Dados

A seguir, discutiremos brevemente cada pasta presente neste repositório:

### 0_Notacao_Big-O1
Contém notebooks e imagens relacionados à notação Big-O, uma forma de analisar e comparar o desempenho de algoritmos.
1. **0-Notação Big-O.ipynb:** Demonstração prática e explicativa da notação Big-O, com exemplos e gráficos para ilustrar a complexidade de diferentes algoritmos.

### 1_Vetor Nao Ordenado
Implementação de um vetor não ordenado e suas operações básicas.
1. **vetornaoOrdenado.ipynb:** Implementação de um vetor não ordenado em Python, com operações básicas como inserção, busca e remoção.

### 2_Vetor Ordenado
Apresenta um vetor ordenado e inclui uma busca binária para otimizar a busca de elementos.
1. **0_vetorOrdenado.ipynb:** Introdução a um vetor ordenado e suas operações básicas.
2. **1_vetorOrdenado_buscaBinaria.ipynb:** Implementação e explicação da busca binária em um vetor ordenado.

### 3_Pilhas
Implementações de uma pilha e um exemplo prático para validar expressões matemáticas.
1. **0_Pilha.ipynb:** Implementação e operações básicas de uma pilha.
2. **1_Pilha_validadorExpressoes.ipynb:** Utilização de pilha para validar expressões matemáticas.

### 4_Filas
Contém uma implementação de fila simples e uma fila de prioridades.
1. **0_fila.ipynb:** Implementação e operações básicas de uma fila.
2. **1_fila_prioridades.ipynb:** Implementação de uma fila de prioridades.

### 5_Deques
Exploração do conceito de deque (double-ended queue) com operações explicativas.
1. **Deque.ipynb:** Notebook explicativo sobre double-ended queues (deques) com operações e exemplos.

### 6_Listas Encadeadas
Diversas implementações de listas encadeadas, incluindo simples, duplamente encadeadas e exemplos práticos de uso.
1. **0_ListaEncadeadaSimples.ipynb:** Implementação e operações básicas de uma lista encadeada simples.
2. **1_ListaEncadeadaExtremidadeDupla.ipynb:** Lista encadeada de extremidade dupla.
3. **2_ListaduplamenteEncadeada.ipynb:** Implementação e operações em uma lista duplamente encadeada.
4. **3_PilhacomListaEncadeada.ipynb:** Utilização de lista encadeada para implementar uma pilha.
5. **4_FilacomListaEncadeada.ipynb:** Utilização de lista encadeada para implementar uma fila.

### 7_Recursão
Notebook explicativo sobre o conceito de recursão e seu uso em algoritmos.
1. **0_Recursão.ipynb:** Explicação do conceito de recursão com exemplos práticos.

### 8_Algoritmos_de_Ordenacao
Contém implementações e notebooks comparativos de vários algoritmos de ordenação, como Bubble Sort, Selection Sort, Insertion Sort, Shell Sort, Merge Sort e Quick Sort.
1. **Comparativo.ipynb:** Comparação prática de vários algoritmos de ordenação.
2. **0_Bubble_Sort/Bubble_Sort.ipynb:** Implementação e explicação do algoritmo Bubble Sort.
3. **1_Select_Sort/Selection_Sort.ipynb:** Implementação e explicação do algoritmo Selection Sort.
4. **2_Insertion_Sort/Insertion_Sort.ipynb:** Implementação e explicação do algoritmo Insertion Sort.
5. **3_Shell_Sort/Shell_Sort.ipynb:** Implementação e explicação do algoritmo Shell Sort.
6. **4_Merge_Sort/Merge_Sort.ipynb:** Implementação e explicação do algoritmo Merge Sort.
7. **5_Quick_Sort/Quick_Sort.ipynb:** Implementação e explicação do algoritmo Quick Sort.

### 9_Árvore_Binária
Introdução a árvores binárias de busca com suas operações básicas.
1. **arvore_binaria_busca.ipynb:** Introdução a árvores binárias de busca e suas operações básicas.

### 10_Grafos
Implementações de algoritmos em grafos, como busca em profundidade, busca em largura, busca gulosa, A* e Dijkstra.
1. **0_grafo_buscaPronfundidade.ipynb:** Implementação e explicação da busca em profundidade em grafos.
2. **1_grafo_BuscaPronfundidadeLargura.ipynb:** Implementação e explicação da busca em largura em grafos.
3. **2_grafo_BuscaGulosa.ipynb:** Implementação e explicação da busca gulosa em grafos.
4. **3_grafo_A_Estrela.ipynb:** Implementação e explicação do algoritmo A* em grafos.
5. **4_grafo_dijkstra.ipynb:** Implementação e explicação do algoritmo de Dijkstra para encontrar o caminho mais curto.
---


Cada subpasta contém um README.md abrangente, fornecendo informações adicionais essenciais para uma compreensão mais profunda das estruturas de dados e algoritmos apresentados.

Sinta-se à vontade para navegar por cada diretório, ampliando seu conhecimento sobre as complexidades e funcionalidades desses conceitos fundamentais na ciência da computação.!
